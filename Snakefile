# Snakefile for MeDIP-seq analysis pipeline

# Import necessary libraries
import glob
from os.path import join

# Load configuration file
configfile: "config.yaml"

# Get all sample names
# This assumes that all input files follow the naming convention: *_r1.fastq.gz
SAMPLES = glob.glob("*_r1.fastq.gz")
SAMPLES = [s.split("_r1.fastq.gz")[0] for s in SAMPLES]

# Separate input and IP samples
# Input samples are control samples, typically without immunoprecipitation
INPUT_SAMPLES = [s for s in SAMPLES if "input" in s]
# IP samples are the actual MeDIP samples
IP_SAMPLES = [s for s in SAMPLES if "ip" in s]  # Changed "output" to "ip" for clarity

# Get conditions (e.g., DP, PP, N)
# This assumes that the condition is the second element when splitting the sample name by '_'
CONDITIONS = list(set([s.split('_')[1] for s in SAMPLES]))

# Define the final output files that should be generated by the pipeline
rule all:
    input:
        # FastQC output for raw reads
        expand(join(config["fastqc_outdir"], "{sample}_r{read}_fastqc.html"), sample=SAMPLES, read=[1,2]),
        # Sorted BAM files after alignment
        expand(join(config["aligned_outdir"], "{sample}_sorted.bam"), sample=SAMPLES),
        # Peak calling results
        expand(join(config["peaks_outdir"], "{condition}_{replicate}_peaks.narrowPeak"), 
               condition=CONDITIONS, replicate=["r1", "r2", "r3", "r4"]),
        # Differential methylation results
        join(config["diff_meth_outdir"], "differential_methylation_results.txt"),
        # Functional annotation results
        join(config["func_annot_outdir"], "go_enrichment_results.csv"),
        join(config["func_annot_outdir"], "kegg_enrichment_results.csv"),
        # MultiQC report
        join(config["qc_outdir"], "multiqc_report.html"),
        # BigWig files for visualization
        expand(join(config["bigwig_outdir"], "{sample}.bw"), sample=SAMPLES),
        # Additional QC plots and metrics
        join(config["qc_outdir"], "fragment_size_distribution.pdf"),
        join(config["qc_outdir"], "cpg_enrichment.txt"),
        join(config["qc_outdir"], "replicate_correlation.pdf"),
        join(config["meth_level_outdir"], "methylation_levels.txt")

# Rule to run FastQC on raw reads
rule fastqc:
    input:
        r1 = "{sample}_r1.fastq.gz",
        r2 = "{sample}_r2.fastq.gz"
    output:
        r1 = join(config["fastqc_outdir"], "{sample}_r1_fastqc.html"),
        r2 = join(config["fastqc_outdir"], "{sample}_r2_fastqc.html")
    shell:
        """
        # Run FastQC on both read 1 and read 2 files
        fastqc {input.r1} -o {config[fastqc_outdir]}/
        fastqc {input.r2} -o {config[fastqc_outdir]}/
        """

# Rule to trim adapters and low-quality bases using Trimmomatic
rule trimmomatic:
    input:
        r1 = "{sample}_r1.fastq.gz",
        r2 = "{sample}_r2.fastq.gz"
    output:
        r1 = join(config["trimmed_outdir"], "{sample}_r1_trimmed.fastq.gz"),
        r2 = join(config["trimmed_outdir"], "{sample}_r2_trimmed.fastq.gz"),
        r1_unpaired = join(config["trimmed_outdir"], "{sample}_r1_unpaired.fastq.gz"),
        r2_unpaired = join(config["trimmed_outdir"], "{sample}_r2_unpaired.fastq.gz")
    log:
        "logs/trimmomatic/{sample}.log"
    params:
        adapters = config["adapters"],
        trimmomatic_params = config["trimmomatic_params"]
    threads: config["threads"]
    shell:
        """
        # Run Trimmomatic in paired-end mode
        trimmomatic PE -threads {threads} {input.r1} {input.r2} \
            {output.r1} {output.r1_unpaired} \
            {output.r2} {output.r2_unpaired} \
            ILLUMINACLIP:{params.adapters}:{params.trimmomatic_params} \
            2> {log}
        """

# Rule to run FastQC on trimmed reads
rule fastqc_trimmed:
    input:
        r1 = join(config["trimmed_outdir"], "{sample}_r1_trimmed.fastq.gz"),
        r2 = join(config["trimmed_outdir"], "{sample}_r2_trimmed.fastq.gz")
    output:
        r1 = join(config["fastqc_outdir"], "{sample}_r1_trimmed_fastqc.html"),
        r2 = join(config["fastqc_outdir"], "{sample}_r2_trimmed_fastqc.html")
    log:
        "logs/fastqc_trimmed/{sample}.log"
    shell:
        """
        # Run FastQC on trimmed read 1 and read 2 files
        fastqc {input.r1} {input.r2} -o {config[fastqc_outdir]}/ 2> {log}
        """

# Rule to align reads to the reference genome using Bowtie2
rule align:
    input:
        r1 = join(config["trimmed_outdir"], "{sample}_r1_trimmed.fastq.gz"),
        r2 = join(config["trimmed_outdir"], "{sample}_r2_trimmed.fastq.gz")
    output:
        join(config["aligned_outdir"], "{sample}.bam")
    params:
        index = config["genome_index"]
    threads: config["threads"]
    shell:
        """
        # Align reads using Bowtie2 and pipe the output to samtools to convert SAM to BAM
        bowtie2 -p {threads} -x {params.index} -1 {input.r1} -2 {input.r2} | \
        samtools view -bS - > {output}
        """

# Rule to sort and index BAM files
rule sort_and_index:
    input:
        join(config["aligned_outdir"], "{sample}.bam")
    output:
        bam = join(config["aligned_outdir"], "{sample}_sorted.bam"),
        bai = join(config["aligned_outdir"], "{sample}_sorted.bam.bai")
    threads: config["threads"]
    shell:
        """
        # Sort BAM file
        samtools sort -@ {threads} {input} -o {output.bam}
        # Index sorted BAM file
        samtools index {output.bam}
        """

# Rule to mark duplicates in BAM files
rule mark_duplicates:
    input:
        join(config["aligned_outdir"], "{sample}_sorted.bam")
    output:
        bam = join(config["dedup_outdir"], "{sample}_markdup.bam"),
        metrics = join(config["dedup_outdir"], "{sample}_markdup_metrics.txt")
    log:
        "logs/mark_duplicates/{sample}.log"
    shell:
        """
        # Mark duplicates using Picard tools
        picard MarkDuplicates I={input} O={output.bam} M={output.metrics} 2> {log}
        """

# Rule to remove duplicates from BAM files
rule remove_duplicates:
    input:
        join(config["aligned_outdir"], "{sample}_sorted.bam")
    output:
        bam = join(config["dedup_outdir"], "{sample}_dedup.bam"),
        metrics = join(config["dedup_outdir"], "{sample}_metrics.txt")
    shell:
        """
        # Remove duplicates using Picard tools
        picard MarkDuplicates I={input} O={output.bam} M={output.metrics} REMOVE_DUPLICATES=true
        """

# Rule to check if all required input files exist before peak calling
rule check_input_files:
    input:
        ip = join(config["dedup_outdir"], "{condition}_output_{replicate}_dedup.bam"),
        control = expand(join(config["dedup_outdir"], "{{condition}}_input_r{input_rep}_dedup.bam"), input_rep=[1,2,3])
    output:
        touch(join(config["peaks_outdir"], "{condition}_{replicate}.input_checked"))
    run:
        for file in input:
            if not os.path.exists(file):
                raise ValueError(f"Input file not found: {file}")

# Rule to call peaks using MACS2
rule call_peaks:
    input:
        ip = join(config["dedup_outdir"], "{condition}_ip_{replicate}_markdup.bam"),
        control = expand(join(config["dedup_outdir"], "{{condition}}_input_r{input_rep}_markdup.bam"), input_rep=[1,2,3])
    output:
        narrowPeak = join(config["peaks_outdir"], "{condition}_{replicate}_peaks.narrowPeak"),
        xls = join(config["peaks_outdir"], "{condition}_{replicate}_peaks.xls")
    params:
        genome_size = config["genome_size"],
        q_value = config["macs2_qvalue"],
        outdir = config["peaks_outdir"]
    log:
        "logs/call_peaks/{condition}_{replicate}.log"
    shell:
        """
        # Call peaks using MACS2
        macs2 callpeak -t {input.ip} -c {input.control} -f BAM -g {params.genome_size} \
            -n {wildcards.condition}_{wildcards.replicate} -q {params.q_value} \
            --outdir {params.outdir} 2> {log}
        """

# Rule to perform differential methylation analysis
rule differential_methylation:
    input:
        peaks = expand(join(config["peaks_outdir"], "{condition}_{replicate}_peaks.narrowPeak"), 
               condition=CONDITIONS, replicate=["r1", "r2", "r3", "r4"]),
        bams = expand(join(config["dedup_outdir"], "{sample}_markdup.bam"), sample=SAMPLES)
    output:
        join(config["diff_meth_outdir"], "differential_methylation_results.txt")
    log:
        "logs/differential_methylation.log"
    script:
        "scripts/differential_methylation.R"
        
# Rule to run MultiQC for aggregating QC reports
rule multiqc:
    input:
        expand(join(config["fastqc_outdir"], "{sample}_r{read}_fastqc.html"), sample=SAMPLES, read=[1,2]),
        expand(join(config["fastqc_outdir"], "{sample}_r{read}_trimmed_fastqc.html"), sample=SAMPLES, read=[1,2]),
        expand(join(config["dedup_outdir"], "{sample}_markdup_metrics.txt"), sample=SAMPLES)
    output:
        join(config["qc_outdir"], "multiqc_report.html")
    log:
        "logs/multiqc.log"
    shell:
        """
        # Run MultiQC to aggregate QC reports
        multiqc {config[fastqc_outdir]} {config[dedup_outdir]} -o {config[qc_outdir]} 2> {log}
        """

# Rule to perform functional annotation of differentially methylated regions
rule functional_annotation:
    input:
        join(config["diff_meth_outdir"], "differential_methylation_results.txt")
    output:
        go_csv = join(config["func_annot_outdir"], "go_enrichment_results.csv"),
        kegg_csv = join(config["func_annot_outdir"], "kegg_enrichment_results.csv"),
        go_plot = join(config["func_annot_outdir"], "go_dotplot.pdf"),
        kegg_plot = join(config["func_annot_outdir"], "kegg_dotplot.pdf")
    script:
        "scripts/functional_annotation.R"

# Rule to create BigWig files for visualization
rule create_bigwig:
    input:
        bam = join(config["dedup_outdir"], "{sample}_markdup.bam")
    output:
        bw = join(config["bigwig_outdir"], "{sample}.bw")
    log:
        "logs/create_bigwig/{sample}.log"
    shell:
        """
        # Create BigWig file using bamCoverage
        bamCoverage -b {input.bam} -o {output.bw} --binSize 10 --normalizeUsing RPKM 2> {log}
        """

# Rule to generate fragment size distribution plot
rule fragment_size_distribution:
    input:
        expand(join(config["dedup_outdir"], "{sample}_markdup.bam"), sample=SAMPLES)
    output:
        join(config["qc_outdir"], "fragment_size_distribution.pdf")
    log:
        "logs/fragment_size_distribution.log"
    script:
        "scripts/fragment_size_distribution.R"

# Rule to calculate CpG enrichment
rule cpg_enrichment:
    input:
        expand(join(config["dedup_outdir"], "{sample}_markdup.bam"), sample=SAMPLES)
    output:
        join(config["qc_outdir"], "cpg_enrichment.txt")
    log:
        "logs/cpg_enrichment.log"
    script:
        "scripts/cpg_enrichment.R"

# Rule to assess replicate correlation
rule replicate_correlation:
    input:
        expand(join(config["dedup_outdir"], "{sample}_markdup.bam"), sample=SAMPLES)
    output:
        join(config["qc_outdir"], "replicate_correlation.pdf")
    log:
        "logs/replicate_correlation.log"
    script:
        "scripts/replicate_correlation.R"

# Rule to calculate methylation levels
rule methylation_levels:
    input:
        bams = expand(join(config["dedup_outdir"], "{sample}_markdup.bam"), sample=SAMPLES),
        peaks = expand(join(config["peaks_outdir"], "{condition}_{replicate}_peaks.narrowPeak"), 
               condition=CONDITIONS, replicate=["r1", "r2", "r3", "r4"])
    output:
        join(config["meth_level_outdir"], "methylation_levels.txt")
    log:
        "logs/methylation_levels.log"
    script:
        "scripts/methylation_levels.R"